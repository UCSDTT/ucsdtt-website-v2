import { S as SvelteComponentDev, i as init, s as safe_not_equal, D as add_render_callback, e as element, t as text, c as claim_element, b as children, d as claim_text, f as detach, g as attr, h as add_location, j as insert, k as append, w as set_data, E as create_in_transition, n as noop, F as svg_element, G as set_style, a as space, x as empty, H as listen, q as transition_in, I as run_all, J as onMount, v as globals, K as create_out_transition, B as group_outros, r as transition_out, C as check_outros, l as create_slot, o as get_slot_changes, p as get_slot_context, m as mount_component, u as destroy_component } from './chunk.b5534b6a.js';
import './chunk.ccbdf3ce.js';
import { f as fade, a as fly } from './chunk.6429a2f7.js';

/* src/components/Hero.svelte generated by Svelte v3.6.2 */

const file = "src/components/Hero.svelte";

// (71:0) {#if visible}
function create_if_block_1(ctx) {
	var h1, t_value = ctx.dispSmall ? ctx.titleSmall : ctx.titleBig, t, h1_intro;

	return {
		c: function create() {
			h1 = element("h1");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t = claim_text(h1_nodes, t_value);
			h1_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(h1, "class", "text-display lg-view svelte-1p2qno9");
			add_location(h1, file, 71, 1, 1248);
		},

		m: function mount(target, anchor) {
			insert(target, h1, anchor);
			append(h1, t);
		},

		p: function update(changed, ctx) {
			if ((changed.dispSmall || changed.titleSmall || changed.titleBig) && t_value !== (t_value = ctx.dispSmall ? ctx.titleSmall : ctx.titleBig)) {
				set_data(t, t_value);
			}
		},

		i: function intro(local) {
			if (!h1_intro) {
				add_render_callback(() => {
					h1_intro = create_in_transition(h1, fade, {});
					h1_intro.start();
				});
			}
		},

		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(h1);
			}
		}
	};
}

// (79:0) {#if visible}
function create_if_block(ctx) {
	var svg_1, path, path_intro;

	return {
		c: function create() {
			svg_1 = svg_element("svg");
			path = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			svg_1 = claim_element(nodes, "svg", { xmlns: true, viewBox: true, width: true, height: true, class: true, style: true }, true);
			var svg_1_nodes = children(svg_1);

			path = claim_element(svg_1_nodes, "path", { d: true, opacity: true }, true);
			var path_nodes = children(path);

			path_nodes.forEach(detach);
			svg_1_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(path, "d", ctx.svg);
			attr(path, "opacity", "0.6");
			add_location(path, file, 87, 2, 1531);
			attr(svg_1, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg_1, "viewBox", "0 0 64 64");
			attr(svg_1, "width", "64px");
			attr(svg_1, "height", "64px");
			attr(svg_1, "class", "parallax svelte-1p2qno9");
			set_style(svg_1, "transform", "translate(0, " + ctx.sy * .4 + "px)");
			add_location(svg_1, file, 79, 1, 1364);
		},

		m: function mount(target, anchor) {
			insert(target, svg_1, anchor);
			append(svg_1, path);
		},

		p: function update(changed, ctx) {
			if (changed.svg) {
				attr(path, "d", ctx.svg);
			}

			if (changed.sy) {
				set_style(svg_1, "transform", "translate(0, " + ctx.sy * .4 + "px)");
			}
		},

		i: function intro(local) {
			if (!path_intro) {
				add_render_callback(() => {
					path_intro = create_in_transition(path, fly, {y: -5, delay: 250});
					path_intro.start();
				});
			}
		},

		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(svg_1);
			}
		}
	};
}

function create_fragment(ctx) {
	var scrolling = false, clear_scrolling = () => { scrolling = false; }, scrolling_timeout, t, if_block1_anchor, dispose;

	add_render_callback(ctx.onwindowscroll);

	add_render_callback(ctx.onwindowresize);

	var if_block0 = (ctx.visible) && create_if_block_1(ctx);

	var if_block1 = (ctx.visible) && create_if_block(ctx);

	return {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t = claim_text(nodes, "\n");
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			dispose = [
				listen(window, "scroll", () => {
					scrolling = true;
					clearTimeout(scrolling_timeout);
					scrolling_timeout = setTimeout(clear_scrolling, 100);
					ctx.onwindowscroll();
				}),
				listen(window, "resize", ctx.onwindowresize)
			];
		},

		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (changed.sy && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window.pageXOffset, ctx.sy);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
			}

			if (ctx.visible) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.visible) {
				if (if_block1) {
					if_block1.p(changed, ctx);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},

		i: function intro(local) {
			transition_in(if_block0);
			transition_in(if_block1);
		},

		o: noop,

		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);

			if (detaching) {
				detach(t);
			}

			if (if_block1) if_block1.d(detaching);

			if (detaching) {
				detach(if_block1_anchor);
			}

			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	

	let visible = false;

	let { svg, titleBig, titleSmall } = $$props;

	let sy = 0;
	let iw = 0;

	onMount(()=> {
		$$invalidate('visible', visible = true);
	});

	const writable_props = ['svg', 'titleBig', 'titleSmall'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Hero> was created with unknown prop '${key}'`);
	});

	function onwindowscroll() {
		sy = window.pageYOffset; $$invalidate('sy', sy);
	}

	function onwindowresize() {
		iw = window.innerWidth; $$invalidate('iw', iw);
	}

	$$self.$set = $$props => {
		if ('svg' in $$props) $$invalidate('svg', svg = $$props.svg);
		if ('titleBig' in $$props) $$invalidate('titleBig', titleBig = $$props.titleBig);
		if ('titleSmall' in $$props) $$invalidate('titleSmall', titleSmall = $$props.titleSmall);
	};

	let dispSmall;

	$$self.$$.update = ($$dirty = { iw: 1 }) => {
		if ($$dirty.iw) { $$invalidate('dispSmall', dispSmall = iw <= 1000); }
	};

	return {
		visible,
		svg,
		titleBig,
		titleSmall,
		sy,
		iw,
		dispSmall,
		onwindowscroll,
		onwindowresize
	};
}

class Hero extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["svg", "titleBig", "titleSmall"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.svg === undefined && !('svg' in props)) {
			console.warn("<Hero> was created without expected prop 'svg'");
		}
		if (ctx.titleBig === undefined && !('titleBig' in props)) {
			console.warn("<Hero> was created without expected prop 'titleBig'");
		}
		if (ctx.titleSmall === undefined && !('titleSmall' in props)) {
			console.warn("<Hero> was created without expected prop 'titleSmall'");
		}
	}

	get svg() {
		throw new Error("<Hero>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set svg(value) {
		throw new Error("<Hero>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get titleBig() {
		throw new Error("<Hero>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set titleBig(value) {
		throw new Error("<Hero>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get titleSmall() {
		throw new Error("<Hero>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set titleSmall(value) {
		throw new Error("<Hero>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/WeAre.svelte generated by Svelte v3.6.2 */
const { Error: Error_1 } = globals;

const file$1 = "src/components/WeAre.svelte";

// (73:8) {#if weAreVisible}
function create_if_block_1$1(ctx) {
	var span, t, span_intro;

	return {
		c: function create() {
			span = element("span");
			t = text("We are");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "We are");
			span_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(span, "class", "formal");
			add_location(span, file$1, 73, 12, 1652);
		},

		m: function mount(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},

		i: function intro(local) {
			if (!span_intro) {
				add_render_callback(() => {
					span_intro = create_in_transition(span, fade, {});
					span_intro.start();
				});
			}
		},

		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (76:8) {#if visible}
function create_if_block$1(ctx) {
	var span, t_value = ctx.brotherLabels[ctx.wordIndex], t, span_intro, span_outro, current;

	return {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(span, "class", "formal");
			add_location(span, file$1, 76, 12, 1744);
		},

		m: function mount(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.brotherLabels || changed.wordIndex) && t_value !== (t_value = ctx.brotherLabels[ctx.wordIndex])) {
				set_data(t, t_value);
			}
		},

		i: function intro(local) {
			if (current) return;
			add_render_callback(() => {
				if (span_outro) span_outro.end(1);
				if (!span_intro) span_intro = create_in_transition(span, ctx.typewriter, {});
				span_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			if (span_intro) span_intro.invalidate();

			span_outro = create_out_transition(span, fade, {duration: 280});

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(span);
				if (span_outro) span_outro.end();
			}
		}
	};
}

function create_fragment$1(ctx) {
	var section, h1, t, current;

	var if_block0 = (ctx.weAreVisible) && create_if_block_1$1();

	var if_block1 = (ctx.visible) && create_if_block$1(ctx);

	return {
		c: function create() {
			section = element("section");
			h1 = element("h1");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", {}, false);
			var section_nodes = children(section);

			h1 = claim_element(section_nodes, "H1", { id: true, class: true }, false);
			var h1_nodes = children(h1);

			if (if_block0) if_block0.l(h1_nodes);
			t = claim_text(h1_nodes, "\n        ");
			if (if_block1) if_block1.l(h1_nodes);
			h1_nodes.forEach(detach);
			section_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(h1, "id", "we-are-container");
			attr(h1, "class", "svelte-h8gpfm");
			add_location(h1, file$1, 71, 4, 1586);
			add_location(section, file$1, 70, 0, 1572);
		},

		m: function mount(target, anchor) {
			insert(target, section, anchor);
			append(section, h1);
			if (if_block0) if_block0.m(h1, null);
			append(h1, t);
			if (if_block1) if_block1.m(h1, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.weAreVisible) {
				if (!if_block0) {
					if_block0 = create_if_block_1$1();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(h1, t);
				} else {
									transition_in(if_block0, 1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.visible) {
				if (if_block1) {
					if_block1.p(changed, ctx);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(h1, null);
				}
			} else if (if_block1) {
				group_outros();
				transition_out(if_block1, 1, () => {
					if_block1 = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(section);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	

    let { brotherLabels } = $$props;

    let visible = false;
    let weAreVisible = false;
    let wordIndex = 0;

    onMount(() => {
        $$invalidate('weAreVisible', weAreVisible = true);
        setInterval(() => {
            $$invalidate('visible', visible = true);
            setTimeout(() => {
                $$invalidate('visible', visible = false);
                $$invalidate('wordIndex', wordIndex = pickNextIndex(wordIndex));
            }, 1000);
        }, 1500);
    });

    function pickNextIndex(curIndex) {
        let nextIndex = Math.floor(Math.random() * brotherLabels.length);
        if (nextIndex === curIndex) {
            return (curIndex + 1) % brotherLabels.length
        }
        return nextIndex;
    }


    function typewriter(node, { speed = 50 }) {
		if (wordIndex < 0 || wordIndex >= brotherLabels.length) {
			throw new Error(`wordIndex out of bounds.`);
		}
            
		const text = brotherLabels[wordIndex];
        const duration = text.length * speed;

		return {
			duration,
			tick: t => {
				const i = ~~(text.length * t);
				node.textContent = text.slice(0, i);
			}
        };
	}

	const writable_props = ['brotherLabels'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<WeAre> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('brotherLabels' in $$props) $$invalidate('brotherLabels', brotherLabels = $$props.brotherLabels);
	};

	return {
		brotherLabels,
		visible,
		weAreVisible,
		wordIndex,
		typewriter
	};
}

class WeAre extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["brotherLabels"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.brotherLabels === undefined && !('brotherLabels' in props)) {
			console.warn("<WeAre> was created without expected prop 'brotherLabels'");
		}
	}

	get brotherLabels() {
		throw new Error_1("<WeAre>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set brotherLabels(value) {
		throw new Error_1("<WeAre>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Card.svelte generated by Svelte v3.6.2 */

const file$2 = "src/components/Card.svelte";

const get_right_slot_changes = () => ({});
const get_right_slot_context = () => ({});

const get_left_slot_changes = () => ({});
const get_left_slot_context = () => ({});

const get_header_slot_changes = () => ({});
const get_header_slot_context = () => ({ class: `header svelte-1b76vzz` });

function create_fragment$2(ctx) {
	var section2, t0, hr, t1, div, section0, t2, section1, current;

	const header_slot_1 = ctx.$$slots.header;
	const header_slot = create_slot(header_slot_1, ctx, get_header_slot_context);

	const left_slot_1 = ctx.$$slots.left;
	const left_slot = create_slot(left_slot_1, ctx, get_left_slot_context);

	const right_slot_1 = ctx.$$slots.right;
	const right_slot = create_slot(right_slot_1, ctx, get_right_slot_context);

	return {
		c: function create() {
			section2 = element("section");

			if (header_slot) header_slot.c();
			t0 = space();
			hr = element("hr");
			t1 = space();
			div = element("div");
			section0 = element("section");

			if (left_slot) left_slot.c();
			t2 = space();
			section1 = element("section");

			if (right_slot) right_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			section2 = claim_element(nodes, "SECTION", { class: true }, false);
			var section2_nodes = children(section2);

			if (header_slot) header_slot.l(section2_nodes);
			t0 = claim_text(section2_nodes, "\n    ");

			hr = claim_element(section2_nodes, "HR", {}, false);
			var hr_nodes = children(hr);

			hr_nodes.forEach(detach);
			t1 = claim_text(section2_nodes, "\n    ");

			div = claim_element(section2_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			section0 = claim_element(div_nodes, "SECTION", { class: true }, false);
			var section0_nodes = children(section0);

			if (left_slot) left_slot.l(section0_nodes);
			section0_nodes.forEach(detach);
			t2 = claim_text(div_nodes, "\n        ");

			section1 = claim_element(div_nodes, "SECTION", { class: true }, false);
			var section1_nodes = children(section1);

			if (right_slot) right_slot.l(section1_nodes);
			section1_nodes.forEach(detach);
			div_nodes.forEach(detach);
			section2_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(hr, file$2, 55, 4, 1011);

			attr(section0, "class", "left-div subcards svelte-1b76vzz");
			add_location(section0, file$2, 57, 8, 1050);

			attr(section1, "class", "right-div subcards svelte-1b76vzz");
			add_location(section1, file$2, 60, 8, 1151);
			attr(div, "class", "wrapper svelte-1b76vzz");
			add_location(div, file$2, 56, 4, 1020);
			attr(section2, "class", "card svelte-1b76vzz");
			add_location(section2, file$2, 53, 0, 937);
		},

		m: function mount(target, anchor) {
			insert(target, section2, anchor);

			if (header_slot) {
				header_slot.m(section2, null);
			}

			append(section2, t0);
			append(section2, hr);
			append(section2, t1);
			append(section2, div);
			append(div, section0);

			if (left_slot) {
				left_slot.m(section0, null);
			}

			append(div, t2);
			append(div, section1);

			if (right_slot) {
				right_slot.m(section1, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (header_slot && header_slot.p && changed.$$scope) {
				header_slot.p(get_slot_changes(header_slot_1, ctx, changed, get_header_slot_changes), get_slot_context(header_slot_1, ctx, get_header_slot_context));
			}

			if (left_slot && left_slot.p && changed.$$scope) {
				left_slot.p(get_slot_changes(left_slot_1, ctx, changed, get_left_slot_changes), get_slot_context(left_slot_1, ctx, get_left_slot_context));
			}

			if (right_slot && right_slot.p && changed.$$scope) {
				right_slot.p(get_slot_changes(right_slot_1, ctx, changed, get_right_slot_changes), get_slot_context(right_slot_1, ctx, get_right_slot_context));
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			transition_in(left_slot, local);
			transition_in(right_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(header_slot, local);
			transition_out(left_slot, local);
			transition_out(right_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(section2);
			}

			if (header_slot) header_slot.d(detaching);

			if (left_slot) left_slot.d(detaching);

			if (right_slot) right_slot.d(detaching);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { section } = $$props;

	const writable_props = ['section'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Card> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('section' in $$props) $$invalidate('section', section = $$props.section);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return { section, $$slots, $$scope };
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["section"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.section === undefined && !('section' in props)) {
			console.warn("<Card> was created without expected prop 'section'");
		}
	}

	get section() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set section(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const garnetUnfilled = "M 33.740234 2.0605469 C 32.610234 2.0605469 31.490234 2.339375 30.490234 2.859375 C 30.490234 2.859375 29.670234 3.2400781 29.490234 3.3300781 L 20.109375 8.0195312 C 19.629375 8.2595313 19.190547 8.5692188 18.810547 8.9492188 L 8.8300781 18.939453 C 8.5100781 19.249453 8.2395312 19.610234 8.0195312 19.990234 L 3.0292969 28.810547 C 2.3792969 29.900547 2.0292969 31.140156 2.0292969 32.410156 L 2.0976562 45.912109 C 2.0496562 46.744109 2.047375 47.552078 2.109375 48.330078 C 2.139375 48.740078 2.1902344 49.150781 2.2402344 49.550781 C 2.4102344 50.620781 2.6903125 51.609297 3.0703125 52.529297 C 3.1903125 52.809297 3.3209375 53.079609 3.4609375 53.349609 C 3.9309375 54.249609 4.5202344 55.069062 5.2402344 55.789062 C 5.5042344 56.053063 5.7813125 56.30025 6.0703125 56.53125 C 6.2393125 56.66625 6.4206563 56.784203 6.5976562 56.908203 C 6.7236563 56.996203 6.8426562 57.091828 6.9726562 57.173828 C 7.2296562 57.336828 7.5013906 57.480094 7.7753906 57.621094 C 7.8343906 57.651094 7.8892187 57.68975 7.9492188 57.71875 C 8.2692188 57.87575 8.6013594 58.014578 8.9433594 58.142578 C 8.9613594 58.149578 8.9790469 58.159016 8.9980469 58.166016 C 10.448047 58.701016 12.096687 58.976188 13.929688 58.992188 C 13.938688 58.993187 13.944125 58.998047 13.953125 58.998047 C 13.969125 59.000047 13.985 59 14 59 C 14.007 59 14.012531 58.996094 14.019531 58.996094 C 14.047531 58.996094 14.071609 59 14.099609 59 C 14.469609 59 14.840938 58.990938 15.210938 58.960938 C 15.670938 58.940937 16.129609 58.899609 16.599609 58.849609 L 16.619141 58.849609 L 55.5 56.910156 C 56.54 56.860156 57.360391 56.030234 57.400391 54.990234 L 58.890625 16.289062 C 58.900625 16.219062 58.970703 14.320391 58.970703 14.150391 C 58.970703 13.392391 58.907453 12.669797 58.814453 11.966797 C 58.771453 11.600797 58.720391 11.240625 58.650391 10.890625 C 58.640391 10.890625 58.640391 10.879141 58.650391 10.869141 C 58.440391 9.8591406 58.130703 8.9205469 57.720703 8.0605469 C 57.220703 7.0205469 56.569766 6.0795312 55.759766 5.2695312 C 53.629766 3.1395313 50.650391 2.0605469 46.900391 2.0605469 L 33.740234 2.0605469 z M 35.119141 4.0605469 L 43.669922 4.0605469 L 43.369141 4.390625 L 40.060547 7.9335938 C 39.689547 7.3175938 39.195312 6.7676094 38.570312 6.3496094 L 37.910156 5.9101562 L 35.890625 4.5703125 L 35.880859 4.5703125 L 35.119141 4.0605469 z M 46.900391 4.0605469 C 50.100391 4.0605469 52.599609 4.9396875 54.349609 6.6796875 C 54.579609 6.9096875 54.790234 7.1501562 54.990234 7.4101562 C 56.321234 9.1281562 56.978984 11.475016 56.958984 14.291016 L 37.683594 20.658203 L 40.539062 12.089844 C 40.768062 11.403844 40.824906 10.696812 40.753906 10.007812 L 46.160156 11.919922 C 46.270156 11.959922 46.380234 11.980469 46.490234 11.980469 C 46.900234 11.980469 47.289453 11.720547 47.439453 11.310547 C 47.619453 10.790547 47.350078 10.219063 46.830078 10.039062 L 42.320312 8.4394531 L 46.390625 4.0703125 C 46.560625 4.0603125 46.730391 4.0605469 46.900391 4.0605469 z M 31.720703 4.8007812 C 32.310703 4.8007812 32.890625 4.9707812 33.390625 5.3007812 L 33.75 5.5390625 L 35.679688 6.8300781 L 37.460938 8.0097656 C 38.580937 8.7597656 39.070625 10.180938 38.640625 11.460938 L 35.490234 20.900391 C 35.320234 21.400391 35.030625 21.849219 34.640625 22.199219 L 22.390625 33.080078 C 22.010625 33.420078 21.550781 33.659531 21.050781 33.769531 L 11.050781 35.990234 C 9.9207813 36.240234 8.7805469 35.829453 8.0605469 34.939453 L 7.4804688 34.210938 L 6.1503906 32.550781 L 6.140625 32.539062 L 5.6699219 31.949219 C 5.2299219 31.409219 5.0097656 30.750078 5.0097656 30.080078 C 5.0097656 29.750078 5.0596875 29.429375 5.1796875 29.109375 C 5.2296875 28.929375 5.3101562 28.759844 5.4101562 28.589844 L 9.7597656 20.980469 C 9.8897656 20.750469 10.050234 20.539609 10.240234 20.349609 L 20.220703 10.369141 C 20.450703 10.139141 20.72 9.9507813 21 9.8007812 L 30.380859 5.109375 C 30.530859 5.039375 30.679844 4.9796875 30.839844 4.9296875 C 31.129844 4.8396875 31.430703 4.8007813 31.720703 4.8007812 z M 50.310547 11.351562 C 49.921625 11.374859 49.564531 11.624875 49.425781 12.015625 C 49.241781 12.536625 49.514156 13.107969 50.035156 13.292969 L 52.482422 14.160156 C 52.592422 14.199156 52.705406 14.21875 52.816406 14.21875 C 53.228406 14.21875 53.613766 13.961781 53.759766 13.550781 C 53.943766 13.030781 53.670391 12.458438 53.150391 12.273438 L 50.703125 11.40625 C 50.573125 11.36025 50.440188 11.343797 50.310547 11.351562 z M 56.873047 16.423828 C 56.877047 16.450828 56.873906 16.483766 56.878906 16.509766 L 56.869141 16.769531 C 55.885141 24.060531 50.844734 33.314406 42.802734 41.566406 C 42.797734 41.542406 42.799969 41.518141 42.792969 41.494141 L 40.242188 32.804688 C 40.086188 32.274687 39.530953 31.967953 39.001953 32.126953 C 38.471953 32.281953 38.168219 32.837187 38.324219 33.367188 L 40.3125 40.146484 L 24.191406 34.160156 L 35.970703 23.689453 C 36.152703 23.527453 36.317656 23.350062 36.472656 23.164062 L 56.873047 16.423828 z M 56.560547 24.810547 L 55.400391 54.910156 L 25.279297 56.419922 C 31.399297 53.829922 37.839609 49.390859 43.599609 43.630859 C 49.619609 37.610859 54.050547 30.980547 56.560547 24.810547 z M 37.345703 25.099609 C 37.216797 25.084812 37.083172 25.095516 36.951172 25.134766 C 36.421172 25.289766 36.118437 25.845 36.273438 26.375 L 37.017578 28.914062 C 37.145578 29.350062 37.543563 29.632813 37.976562 29.632812 C 38.069563 29.632812 38.163813 29.619797 38.257812 29.591797 C 38.787813 29.436797 39.090547 28.881563 38.935547 28.351562 L 38.191406 25.8125 C 38.074406 25.415 37.732422 25.144 37.345703 25.099609 z M 4.0292969 33.089844 C 4.0492969 33.129844 4.079375 33.159219 4.109375 33.199219 L 5.1796875 34.529297 L 6.4902344 36.179688 C 6.5002344 36.199688 6.5192969 36.220469 6.5292969 36.230469 C 6.9452969 36.736469 7.4442344 37.138453 7.9902344 37.439453 C 7.9872344 37.529453 12.708984 56.933594 12.708984 56.933594 C 11.832984 56.856594 11.021578 56.699656 10.267578 56.472656 C 10.183578 56.447656 10.097625 56.423484 10.015625 56.396484 C 9.839625 56.338484 9.6709531 56.273031 9.5019531 56.207031 C 9.3839531 56.160031 9.2634375 56.1135 9.1484375 56.0625 C 9.0034375 55.9985 8.8636094 55.931328 8.7246094 55.861328 C 8.5906094 55.793328 8.4590781 55.722438 8.3300781 55.648438 C 8.2130781 55.581437 8.097375 55.513406 7.984375 55.441406 C 7.833375 55.344406 7.6879219 55.239766 7.5449219 55.134766 C 7.4599219 55.072766 7.3720625 55.012266 7.2890625 54.947266 C 7.0660625 54.769266 6.8514375 54.581859 6.6484375 54.380859 C 4.5694375 52.289859 3.73 49.210781 4 45.550781 L 7.5292969 40.25 C 7.8392969 39.79 7.7197656 39.169141 7.2597656 38.869141 C 6.7997656 38.559141 6.1791406 38.680625 5.8691406 39.140625 L 4.9492188 40.509766 L 4.9492188 40.529297 L 4.0292969 41.900391 L 4.0292969 33.089844 z M 22.130859 35.527344 L 41.484375 42.714844 C 41.532375 42.732844 41.583813 42.729234 41.632812 42.740234 C 33.416812 50.775234 23.95 56.028141 16.25 56.869141 L 16.089844 56.880859 C 16.004844 56.889859 15.927703 56.894344 15.845703 56.902344 C 15.783703 56.907344 15.719203 56.913969 15.658203 56.917969 C 15.579203 56.925969 15.502828 56.9305 15.423828 56.9375 L 19.464844 45.195312 C 19.644844 44.673313 19.36675 44.105781 18.84375 43.925781 C 18.32175 43.744781 17.751266 44.023875 17.572266 44.546875 L 14.162109 54.457031 L 10.142578 38.046875 C 10.221578 38.050875 10.300859 38.060547 10.380859 38.060547 C 10.750859 38.060547 11.120469 38.019453 11.480469 37.939453 L 21.490234 35.720703 C 21.708234 35.670703 21.921859 35.604344 22.130859 35.527344 z M 45.904297 43.990234 C 45.648547 43.990234 45.392766 44.087703 45.197266 44.283203 L 43.783203 45.697266 C 43.392203 46.087266 43.392203 46.720328 43.783203 47.111328 C 43.978203 47.306328 44.234234 47.404297 44.490234 47.404297 C 44.746234 47.404297 45.002266 47.306328 45.197266 47.111328 L 46.611328 45.697266 C 47.002328 45.306266 47.002328 44.674203 46.611328 44.283203 C 46.415828 44.087703 46.160047 43.990234 45.904297 43.990234 z M 49.439453 47.523438 C 49.183703 47.523437 48.927922 47.620906 48.732422 47.816406 L 47.318359 49.232422 C 46.927359 49.623422 46.927359 50.255484 47.318359 50.646484 C 47.513359 50.842484 47.769391 50.939453 48.025391 50.939453 C 48.281391 50.939453 48.537422 50.841484 48.732422 50.646484 L 50.146484 49.230469 C 50.537484 48.839469 50.537484 48.207406 50.146484 47.816406 C 49.950984 47.620906 49.695203 47.523438 49.439453 47.523438 z M 52.976562 51.060547 C 52.720812 51.060547 52.465031 51.158016 52.269531 51.353516 L 50.853516 52.767578 C 50.462516 53.158578 50.462516 53.790641 50.853516 54.181641 C 51.048516 54.376641 51.304547 54.474609 51.560547 54.474609 C 51.816547 54.474609 52.072578 54.376641 52.267578 54.181641 L 53.683594 52.767578 C 54.074594 52.376578 54.074594 51.744516 53.683594 51.353516 C 53.488094 51.158016 53.232313 51.060547 52.976562 51.060547 z";

/* src/routes/index.svelte generated by Svelte v3.6.2 */

const file$3 = "src/routes/index.svelte";

// (81:2) <h3 slot="header">
function create_header_slot(ctx) {
	var h3, strong, t;

	return {
		c: function create() {
			h3 = element("h3");
			strong = element("strong");
			t = text("UC San Diego's premier engineering fraternity");
			this.h();
		},

		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { slot: true, class: true }, false);
			var h3_nodes = children(h3);

			strong = claim_element(h3_nodes, "STRONG", {}, false);
			var strong_nodes = children(strong);

			t = claim_text(strong_nodes, "UC San Diego's premier engineering fraternity");
			strong_nodes.forEach(detach);
			h3_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(strong, file$3, 81, 4, 1328);
			attr(h3, "slot", "header");
			attr(h3, "class", "svelte-171vvm7");
			add_location(h3, file$3, 80, 2, 1305);
		},

		m: function mount(target, anchor) {
			insert(target, h3, anchor);
			append(h3, strong);
			append(strong, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(h3);
			}
		}
	};
}

// (84:2) <section slot="left">
function create_left_slot(ctx) {
	var section, p0, t0, strong0, t1, t2, strong1, t3, t4, strong2, t5, t6, strong3, t7, t8, t9, p1, t10, strong4, t11, t12, t13, p2, t14, strong5, t15, t16;

	return {
		c: function create() {
			section = element("section");
			p0 = element("p");
			t0 = text("Formed in 1904 with chapters in over 80 campuses, Theta Tau is both the\n      ");
			strong0 = element("strong");
			t1 = text("nation's largest and oldest co-ed engineering fraternity");
			t2 = text(".\n      Our brothers develop each other to not only focus on one aspect of\n      ourselves, but on many. We strive to be well-rounded people who excel in\n      ");
			strong1 = element("strong");
			t3 = text("brotherhood");
			t4 = text(",\n      ");
			strong2 = element("strong");
			t5 = text("philanthropy");
			t6 = text(", and\n      ");
			strong3 = element("strong");
			t7 = text("professionalism");
			t8 = text(".");
			t9 = space();
			p1 = element("p");
			t10 = text("Brothers assist each other with homework, open doors professionally,\n      provide a support system, improve the world for those in need, and hang\n      out with each other among many more things. In addition, a deep,\n      multidisciplinary network of alumni is always there to help at any time.\n      Most importantly, Theta Tau has brought people together to form\n      ");
			strong4 = element("strong");
			t11 = text("connections that will last a lifetime");
			t12 = text(".");
			t13 = space();
			p2 = element("p");
			t14 = text("No matter where your interests lie or what kind of engineer you may be,\n      ");
			strong5 = element("strong");
			t15 = text("come check us out");
			t16 = text("!");
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true }, false);
			var section_nodes = children(section);

			p0 = claim_element(section_nodes, "P", { class: true }, false);
			var p0_nodes = children(p0);

			t0 = claim_text(p0_nodes, "Formed in 1904 with chapters in over 80 campuses, Theta Tau is both the\n      ");

			strong0 = claim_element(p0_nodes, "STRONG", {}, false);
			var strong0_nodes = children(strong0);

			t1 = claim_text(strong0_nodes, "nation's largest and oldest co-ed engineering fraternity");
			strong0_nodes.forEach(detach);
			t2 = claim_text(p0_nodes, ".\n      Our brothers develop each other to not only focus on one aspect of\n      ourselves, but on many. We strive to be well-rounded people who excel in\n      ");

			strong1 = claim_element(p0_nodes, "STRONG", {}, false);
			var strong1_nodes = children(strong1);

			t3 = claim_text(strong1_nodes, "brotherhood");
			strong1_nodes.forEach(detach);
			t4 = claim_text(p0_nodes, ",\n      ");

			strong2 = claim_element(p0_nodes, "STRONG", {}, false);
			var strong2_nodes = children(strong2);

			t5 = claim_text(strong2_nodes, "philanthropy");
			strong2_nodes.forEach(detach);
			t6 = claim_text(p0_nodes, ", and\n      ");

			strong3 = claim_element(p0_nodes, "STRONG", {}, false);
			var strong3_nodes = children(strong3);

			t7 = claim_text(strong3_nodes, "professionalism");
			strong3_nodes.forEach(detach);
			t8 = claim_text(p0_nodes, ".");
			p0_nodes.forEach(detach);
			t9 = claim_text(section_nodes, "\n    ");

			p1 = claim_element(section_nodes, "P", { class: true }, false);
			var p1_nodes = children(p1);

			t10 = claim_text(p1_nodes, "Brothers assist each other with homework, open doors professionally,\n      provide a support system, improve the world for those in need, and hang\n      out with each other among many more things. In addition, a deep,\n      multidisciplinary network of alumni is always there to help at any time.\n      Most importantly, Theta Tau has brought people together to form\n      ");

			strong4 = claim_element(p1_nodes, "STRONG", {}, false);
			var strong4_nodes = children(strong4);

			t11 = claim_text(strong4_nodes, "connections that will last a lifetime");
			strong4_nodes.forEach(detach);
			t12 = claim_text(p1_nodes, ".");
			p1_nodes.forEach(detach);
			t13 = claim_text(section_nodes, "\n    ");

			p2 = claim_element(section_nodes, "P", { class: true }, false);
			var p2_nodes = children(p2);

			t14 = claim_text(p2_nodes, "No matter where your interests lie or what kind of engineer you may be,\n      ");

			strong5 = claim_element(p2_nodes, "STRONG", {}, false);
			var strong5_nodes = children(strong5);

			t15 = claim_text(strong5_nodes, "come check us out");
			strong5_nodes.forEach(detach);
			t16 = claim_text(p2_nodes, "!");
			p2_nodes.forEach(detach);
			section_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(strong0, file$3, 86, 6, 1515);
			add_location(strong1, file$3, 89, 6, 1748);
			add_location(strong2, file$3, 90, 6, 1784);
			add_location(strong3, file$3, 91, 6, 1825);
			attr(p0, "class", "svelte-171vvm7");
			add_location(p0, file$3, 84, 4, 1427);
			add_location(strong4, file$3, 99, 6, 2255);
			attr(p1, "class", "svelte-171vvm7");
			add_location(p1, file$3, 93, 4, 1872);
			add_location(strong5, file$3, 103, 6, 2412);
			attr(p2, "class", "svelte-171vvm7");
			add_location(p2, file$3, 101, 4, 2324);
			attr(section, "slot", "left");
			add_location(section, file$3, 83, 2, 1401);
		},

		m: function mount(target, anchor) {
			insert(target, section, anchor);
			append(section, p0);
			append(p0, t0);
			append(p0, strong0);
			append(strong0, t1);
			append(p0, t2);
			append(p0, strong1);
			append(strong1, t3);
			append(p0, t4);
			append(p0, strong2);
			append(strong2, t5);
			append(p0, t6);
			append(p0, strong3);
			append(strong3, t7);
			append(p0, t8);
			append(section, t9);
			append(section, p1);
			append(p1, t10);
			append(p1, strong4);
			append(strong4, t11);
			append(p1, t12);
			append(section, t13);
			append(section, p2);
			append(p2, t14);
			append(p2, strong5);
			append(strong5, t15);
			append(p2, t16);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(section);
			}
		}
	};
}

// (108:4) {#if iw > 1000}
function create_if_block$2(ctx) {
	var iframe, t0, figcaption, t1;

	return {
		c: function create() {
			iframe = element("iframe");
			t0 = space();
			figcaption = element("figcaption");
			t1 = text("Our rush video for Spring 2019!");
			this.h();
		},

		l: function claim(nodes) {
			iframe = claim_element(nodes, "IFRAME", { id: true, width: true, height: true, title: true, "max-width": true, src: true, frameborder: true, allow: true, allowfullscreen: true, class: true }, false);
			var iframe_nodes = children(iframe);

			iframe_nodes.forEach(detach);
			t0 = claim_text(nodes, "\n      ");

			figcaption = claim_element(nodes, "FIGCAPTION", { class: true }, false);
			var figcaption_nodes = children(figcaption);

			t1 = claim_text(figcaption_nodes, "Our rush video for Spring 2019!");
			figcaption_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(iframe, "id", "rush-video");
			attr(iframe, "width", "960");
			attr(iframe, "height", "540");
			attr(iframe, "title", "SP19 rush video");
			attr(iframe, "max-width", "calc(100vw - 4em)");
			attr(iframe, "src", "https://www.youtube.com/embed/FLfQ3UrGNKk");
			attr(iframe, "frameborder", "0");
			attr(iframe, "allow", "accelerometer; autoplay; encrypted-media; gyroscope;\n        picture-in-picture");
			iframe.allowFullscreen = true;
			attr(iframe, "class", "svelte-171vvm7");
			add_location(iframe, file$3, 110, 6, 2567);
			attr(figcaption, "class", "svelte-171vvm7");
			add_location(figcaption, file$3, 121, 6, 2919);
		},

		m: function mount(target, anchor) {
			insert(target, iframe, anchor);
			insert(target, t0, anchor);
			insert(target, figcaption, anchor);
			append(figcaption, t1);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(iframe);
				detach(t0);
				detach(figcaption);
			}
		}
	};
}

// (107:2) <figure slot="right">
function create_right_slot(ctx) {
	var figure;

	var if_block = (ctx.iw > 1000) && create_if_block$2();

	return {
		c: function create() {
			figure = element("figure");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			figure = claim_element(nodes, "FIGURE", { slot: true }, false);
			var figure_nodes = children(figure);

			if (if_block) if_block.l(figure_nodes);
			figure_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			attr(figure, "slot", "right");
			add_location(figure, file$3, 106, 2, 2472);
		},

		m: function mount(target, anchor) {
			insert(target, figure, anchor);
			if (if_block) if_block.m(figure, null);
		},

		p: function update(changed, ctx) {
			if (ctx.iw > 1000) {
				if (!if_block) {
					if_block = create_if_block$2();
					if_block.c();
					if_block.m(figure, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(figure);
			}

			if (if_block) if_block.d();
		}
	};
}

// (80:0) <Card>
function create_default_slot(ctx) {
	var t0, t1;

	return {
		c: function create() {
			t0 = space();
			t1 = space();
		},

		l: function claim(nodes) {
			t0 = claim_text(nodes, "\n  ");
			t1 = claim_text(nodes, "\n  ");
		},

		m: function mount(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
			}
		}
	};
}

function create_fragment$3(ctx) {
	var t0, div, t1, t2, current, dispose;

	add_render_callback(ctx.onwindowresize);

	var hero = new Hero({
		props: {
		titleBig: "UCSD Theta Tau",
		titleSmall: "UCSD ΘΤ",
		tagline: "Epsilon Delta",
		svg: garnetUnfilled,
		alt: "a hero"
	},
		$$inline: true
	});

	var weare = new WeAre({
		props: { brotherLabels: ctx.brotherLabels },
		$$inline: true
	});

	var card = new Card({
		props: {
		$$slots: {
		default: [create_default_slot],
		right: [create_right_slot],
		left: [create_left_slot],
		header: [create_header_slot]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	return {
		c: function create() {
			t0 = space();
			div = element("div");
			hero.$$.fragment.c();
			t1 = space();
			weare.$$.fragment.c();
			t2 = space();
			card.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			t0 = claim_text(nodes, "\n\n");

			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			hero.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach);
			t1 = claim_text(nodes, "\n");
			weare.$$.fragment.l(nodes);
			t2 = claim_text(nodes, "\n\n");
			card.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			document.title = "UCSD Theta Tau";
			attr(div, "class", "hero-div svelte-171vvm7");
			add_location(div, file$3, 69, 0, 1103);
			dispose = listen(window, "resize", ctx.onwindowresize);
		},

		m: function mount(target, anchor) {
			insert(target, t0, anchor);
			insert(target, div, anchor);
			mount_component(hero, div, null);
			insert(target, t1, anchor);
			mount_component(weare, target, anchor);
			insert(target, t2, anchor);
			mount_component(card, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var hero_changes = {};
			if (changed.garnetUnfilled) hero_changes.svg = garnetUnfilled;
			hero.$set(hero_changes);

			var weare_changes = {};
			if (changed.brotherLabels) weare_changes.brotherLabels = ctx.brotherLabels;
			weare.$set(weare_changes);

			var card_changes = {};
			if (changed.$$scope || changed.iw) card_changes.$$scope = { changed, ctx };
			card.$set(card_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(hero.$$.fragment, local);

			transition_in(weare.$$.fragment, local);

			transition_in(card.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(hero.$$.fragment, local);
			transition_out(weare.$$.fragment, local);
			transition_out(card.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(t0);
				detach(div);
			}

			destroy_component(hero, );

			if (detaching) {
				detach(t1);
			}

			destroy_component(weare, detaching);

			if (detaching) {
				detach(t2);
			}

			destroy_component(card, detaching);

			dispose();
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	

  const brotherLabels = [
    "brothers",
    "entrepreneurs",
    "leaders",
    "pioneers",
    "philanthropists",
    "friends",
    "family",
    "diverse",
    "adventurers",
    "pro gamers",
    "youtube stars",
    "CEOs",
    "project managers",
    "artists",
    "inclusive"
  ];

  let iw;

	function onwindowresize() {
		iw = window.innerWidth; $$invalidate('iw', iw);
	}

	return { brotherLabels, iw, onwindowresize };
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, []);
	}
}

export default Index;
